# Системное проектирование

# Лекция 1. Основы архитектуры ПО и принципы проектирования

**Длительность:** 90 минут<br>
**Версия:** 1.3 (январь 2026)

---

## Цели и ожидаемые результаты

После лекции студент должен уметь:

- Определять роль архитектуры в жизненном цикле разработки ПО.
- Применять базовые архитектурные принципы (SOLID, KISS, DRY, YAGNI) при проектировании компонентов.
- Проводить границу между архитектурными решениями и их реализацией.
- Оценивать архитектурные характеристики (надёжность, масштабируемость, отказоустойчивость).

---

## Ключевые термины

- Архитектура ПО
- Архитектурное решение
- Архитектурные характеристики (quality attributes)
- Принципы SOLID
- KISS (Keep It Simple, Stupid)
- DRY (Don’t Repeat Yourself)
- YAGNI (You Aren’t Gonna Need It)
- Архитектурный артефакт
- Жизненный цикл ПО

---

## План и тайминг лекции (оценка времени)

1. **Введение: зачем нужна архитектура ПО** — 15 мин (теория + обсуждение примера)
2. **Архитектура в жизненном цикле разработки** — 15 мин (теория + кейс + вопросы)
3. **Архитектурные принципы: мышление и практика** — 20 мин (теория + кейс + вопросы)
4. **Граница между архитектурой и реализацией** — 15 мин (теория + кейс + обсуждение)
5. **Архитектурные характеристики и их оценка** — 15 мин (атрибуты, методы оценки, компромиссы)
6. **Подведение итогов и обсуждение** — 10 мин

Итого: ~90 минут

---

# Разделы лекции

## Зачем нужна архитектура ПО

**Вводный вопрос:** чем архитектура отличается от «хорошего кода»? Можно ли без архитектора? *(Цель вопрос настрить студентов на тему лекции, ответ будет даваться в течение лекции)*

### Роли в архитектуре

Архитектурные решения обычно принимаются коллективно, но с разной степенью ответственности и влияния.

**Бизнес-заказчик (Product Owner)** задаёт бизнес-цели, сроки, бюджетные ограничения, приоритеты. Как правило, не выбирает протоколы/технологии и не определяет структуру сервисов.

**Архитектор** отвечает за целостность системы и ключевые решения: границы модулей/сервисов, способы взаимодействия (sync/async), принципы и ограничения, но не фиксирует детали реализации (конкретные библиотеки, диаграммы классов, алгоритмы).

**Tech Lead** проверяет реализуемость архитектурных идей, переводит их в план работ, декомпозирует до задач для команды и синхронизирует ожидания между бизнесом и инженерией.

**Команда разработчиков** реализует решения, подсвечивает проблемы в текущей архитектуре и предлагает эволюционные улучшения.

Важно: роли могут совмещаться (например, техлид = архитектор), а роль архитектора иногда выполняет архитектурный комитет.

### Архитектура в жизненном цикле разработки

Архитектура сопровождает систему на всех этапах жизненного цикла: анализ требований, проектирование, разработка, тестирование, эксплуатация и эволюция.

На стадии анализа бизнес-заказчики и аналитики формулируют ожидания, архитектор переводит их в требования к системе. На этапе проектирования архитектор вместе с ведущими инженерами принимает ключевые решения, фиксирует их в артефактах и обсуждает на архитектурных совещаниях. В процессе разработки команда разработчиков может предлагать изменения, которые обсуждаются и принимаются коллегиально. Таким образом, архитектура — это командный процесс: архитектор задаёт рамки и координирует, инженеры реализуют и уточняют решения.

Проработка архитектуры зависит от модели разработки. В waterfall архитектура проектируется заранее и фиксируется до начала реализации, что даёт предсказуемость, но ограничивает гибкость. В гибких методологиях (scrum, kanban) архитектура развивается итеративно: сначала формируются базовые решения, затем уточняются и корректируются по мере появления новых требований и обратной связи.

Выбор модели разработки — управленческое решение: под продукт с жёсткими требованиями чаще подходит каскадная модель, а для инновационного продукта - гибкая. В обоих случаях архитектура сохраняет ключевую роль, но проявляется по-разному.

Архитектура не статична: она должна развиваться вместе с проектом. На ранних этапах достаточно зафиксировать основы, но по мере роста требований и нагрузки решения пересматриваются и дополняются. Эволюция архитектуры означает адаптацию: одни компоненты становятся отдельными сервисами, другие заменяются более надёжными технологиями. Важно находить баланс между стабильностью и гибкостью.

Архитектура служит языком общения между различными стейкхолдерами: разработчиками, менеджерами, бизнес-заказчиками. Она фиксирует решения в форме диаграмм, описаний и правил, снижая риск разночтений.

Архитектура задаёт рамки для изменений: если система развивается без архитектурной концепции, каждое новое требование ведёт к хаотичному наращиванию кода и росту технического долга.

Кроме того, архитектура формирует основу для оценки качества системы: можно заранее определить, что для бизнеса важнее — скорость разработки, масштабируемость или надёжность, и на этом строить проектные решения.

**Пример:** Система онлайн бронирования билетов, проектировалась под текущий профиль нагрузки. При росте числа пользователей система начинает деградировать. Требуется пересмотр архитектуры учетом роста нагрузки и рефакторинг текущего решения. На уровне архитектуры фиксируем возможность горизонтального масштабирования. Перерабатываем систему с учетом этого требования.

**Пример:** финтех-стартап → переработка архитектуры после роста требований ЦБ.

Невозможно учесть все нюансы в самом начале разработки. Требования могут изменяться: бизнес может сменить вектор развития; могут появиться новые требования со стороны законодательства. Архитектура должна разиваться так же как и развивается програмное обеспечение.

---

## Архитектурные принципы

**Теория:** Архитектурные принципы помогают принимать согласованные решения и бороться со сложностью. Ключевые из них: SOLID, KISS, DRY, YAGNI. Каждый принцип — не жёсткое правило, а способ мыслить об архитектуре.

- **SOLID**: на уровне модулей обеспечивает гибкость и расширяемость; на уровне сервисов — чёткое распределение ответственности. Пример: сервис оплаты отвечает только за транзакции, а сервис уведомлений — за сообщения. DIP означает, что бизнес-логика работает через абстракции (интерфейс платёжного провайдера), а не привязана к Системе Быстрых Платежей или Оплата картой.
- **KISS**: простота важнее усложнённых решений. Архитектурный уровень: не вводить микросервисы без необходимости, если монолит решает задачи быстрее и дешевле.
- **DRY**: предотвращает дублирование логики. На архитектурном уровне — единые сервисы для общей функциональности (например, централизованная аутентификация). Иногда дублирование проще и надёжнее, чем сложная абстракция.
- **YAGNI**: не внедрять функциональность «на будущее». Решения должны соответствовать текущим задачам бизнеса.

Принципы могут вступать в противоречие. KISS требует простоты, но следование DRY рождает сложные абстракции. SOLID призывает к гибкости, но может нарушать YAGNI, если проектируется «с запасом».

Роль архитектора — распознавать конфликты и принимать осознанные решения в конкретном контексте. Баланс достигается через обсуждение с командой, фиксацию компромиссов в артефактах и проверку решений на соответствие бизнес-целям.

**Пример:** CRM на микросервисах для 50 пользователей → нарушение YAGNI.

**Вопросы:** когда нарушение YAGNI оправдано? что опаснее — избыточная сложность или чрезмерная простота?

---

## Граница между архитектурой и реализацией

**Теория:** архитектурные решения = структура и границы; реализационные = конкретные технологии.

Если архитектор детализирует схему до уровня библиотек и алгоритмов, это уже область реализации. Архитектура должна задавать рамки и принципы, а не пошаговый рецепт.

Граница проходит там, где решение определяет долгосрочную структуру системы: какие сервисы выделены, какие протоколы взаимодействия выбраны, как распределяются зоны ответственности. Детали того, какая именно библиотека или фреймворк используется, относятся к реализации и могут меняться без пересмотра архитектуры.

Архитектура отвечает на вопрос «что и зачем?», а реализация — «как именно?». Поэтому документация фиксирует первые решения и оставляет разработчикам свободу выбора инструментов.

Архитектор принимает решения о структуре и границах, инженер — о конкретных технологиях и реализации. Когда архитектор спускается в детали библиотек, это ограничивает инженеров и перегружает документацию.

Типовые ошибки смешения уровней: фиксировать конкретный язык программирования как часть архитектуры; закреплять конкретную ORM или библиотеку логирования как «обязательную» в архитектуре. Такие антипаттерны ведут к жёсткости и техническому долгу.

**Пример:** интернет-магазин → выбрать конкретную ORM-библиотеку для хранения данных заказа.
Т.к. выбор библиотек не влияет на определение границ доменов, контрактов и протоколов взаимодействия, зоны ответсвенности, а только на детали реализации, то выбор ORM не является архитектурной задачей и не должен отражаться в архитектурных артефактах. Верно и обратное, выбранные языки/библиотеки/фреймворки не должны влиять на архитектурные решения.

**Вопросы:** является ли выбор СУБД архитектурным решением? *(И да, и нет. Дать студентам 2 минуты на обсуждение)*

---

## Архитектурные характеристики и их оценка

### Архитектурные характеристики

- **Надёжность** — способность системы работать без сбоев в течение заданного времени.
- **Доступность** - сколько времени сервис доступен пользователю.
- **Масштабируемость** — сохранение эффективности при росте нагрузки, возможность увеличивать ресурсы.
- **Отказоустойчивость** — работа при сбоях отдельных компонентов; достигается за счёт резервирования и дублирования.
- **Производительность** — скорость реакции системы: время отклика, пропускная способность, задержки.
- **Безопасность** — защита данных и предотвращение несанкционированного доступа.
- **Поддерживаемость** — лёгкость внесения изменений и исправлений без нарушения работы.

**Пример доступности:** в пятницу вечером сайт/приложение почти час не открывается или API не отвечает - пользователи не могут начать поиск и бронирование. Это падение доступности (uptime), даже если внутри "логика правильная".

**Пример Надежности:** сайт открывается и выглядит "живым", поиск работает, но при оплате или подтверждении брони периодически происходят сбои: бронь не создаётся, создаётся дважды, списание прошло, а билет не выписался, или подтверждение приходит не на тот рейс. Система формально доступна, но ей нельзя доверять - это проблема надёжности (корректности и предсказуемости работы).

### Компромиссы между качествами

- **Latency vs Availability**: уменьшение задержек снижает устойчивость. Часто выбор между быстрым откликом и гарантированной доступностью.
- **Flexibility vs Complexity**: избыточная гибкость (слишком мелкие сервисы) усложняет поддержку. Ограничение гибкости может повысить стабильность.
- **Security vs Usability**: повышение безопасности (2FA, строгие политики) делает систему менее удобной. Архитектор балансирует между защитой и удобством.

*Пример (онлайн-заказ пиццы):* хранение заказов в распределённой базе повышает доступность, но увеличивает задержки при записи.

**Вопросы:** как приоритизировать характеристики? какие компромиссы типичны?

### CAP Теорема

CAP-теорема — утверждение о том, что в распределённых системах нельзя одновременно добиться трёх свойств:

- Consistency — на всех не отказавших узлах одинаковые (с точки зрения пользователя) данные
- Availability — запросы ко всем не отказавшим узлам возвращают ответ
- Partition tolerance — даже если связь в системе стала нестабильной (вплоть до разделения системы на куски), но узлы работают, то система в целом продолжает работать

Одна из самых известных распределенных систем - DNS. В ней достигнуты "высокая доступность" и "усточивость к разделению" ценой не всегда согласованных данных. Другими словами, при изменениях DNS-записей, разные DNS-серверы какое-то время могут отдавать разные данные. Т.к. в DNS преимущественно читающая нагрузка, то такой компромис не сильно сказывается на Надежности системы.

### SLA/SLO/SLI

- **SLA** - Service Level Agreement - внешнее обещание в договоре или публичных условиях с последствиями в случае нарушений. Пример: Сервис доступен 99.5% в месяц, иначе компенсация.
- **SLO** - Service Level Objective - внутренняя цель/планка к которой стремится компания. Всегда выше, чем SLA, что бы был запас.
- **SLI** - измеримая метрика, которая показывает, насколько хорошо сервис реально работает с точки зрения пользователя. 
- **"Девяточность" сервиса** - количество девяток в SLA. 99.9% - 3 девятки, 99.999% - пять девяток.

**Пример:** [SLA](https://yandex.ru/legal/cloud_sla_ydb/ru/) для Yandex DB

**Задание:** Посчитать SLA за период в 30 дней в минутах: 99.9% и 99.99%


### Методы оценки архитектуры

- **Сценарное моделирование качества** — формулировка сценариев («что произойдёт, если…») и проверка, выполняются ли архитектурные характеристики.
- **ATAM (Architecture Tradeoff Analysis Method)** — метод анализа архитектуры, позволяющий выявлять компромиссы между характеристиками, обсуждать их с заказчиками и фиксировать решения.
- **Risk Storming** — командная практика, где участники отмечают риски на диаграммах и обсуждают меры по их снижению.
- **Нагрузочное и хаос-тестирование** — практическая проверка устойчивости.

*Пример (онлайн-заказ пиццы):* моделирование отказа сервиса оплаты. На сессии risk storming выявлен риск потери заказов. Решение — очередь сообщений, сохраняющая заказы до восстановления сервиса.

**Вопрос:** Вы собрались командой, чтобы найти "узкие" места в системе в основных пользовательских сценариях. Какой это метод оценки?

---

## Подведение итогов и обсуждение

**Резюме:** архитектура = набор структурных решений и компромиссов; сопровождает систему на всём жизненном цикле; принципы помогают бороться со сложностью; характеристики фиксируются и проверяются.

Ключевые мысли лекции:

- Архитектура нужна для управления сложностью и перевода бизнес-целей в инженерные решения.
- Она должна развиваться вместе с системой и соотноситься с выбранной моделью разработки.
- Принципы (SOLID, KISS, DRY, YAGNI) помогают мыслить архитектурно, но требуют баланса и компромиссов.
- Нужно различать архитектурные и реализационные решения.
- Архитектурные характеристики (надёжность, масштабируемость, безопасность и др.) определяют качество и должны проверяться методами оценки.


# Контрольные вопросы

1. Чем архитектура отличается от реализации?
2. Назовите 3 основных принципа архитектуры и приведите пример.
3. Что значит «архитектура должна жить вместе с системой»?
4. Какие бывают архитектурные характеристики и как их проверять?

---

# Допущения

- Примеры кейсов даны в обобщённой форме.
- Глубокая детализация архитектурных стилей и паттернов переносится в последующие лекции.
