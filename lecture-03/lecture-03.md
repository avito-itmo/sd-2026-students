# Лекция 3 — Декомпозиция систем и взаимодействие компонентов

**Версия:** 1.1 (15 янв. 2026)

## План лекции

- **Раздел 1.** Принципы декомпозиции: как и по чему делить
- **Раздел 2.** Связанность, зацепление, метрики
- **Раздел 3.** Интерфейсы и контракты между компонентами

---

## Раздел 1. Принципы декомпозиции: как и почему делить

Чаще всего о декомпозиции говорят в контексте **микросервисов**. Но делить систему можно и иначе: на уровне кода (пакеты/библиотеки), на уровне модулей внутри монолита, на уровне процессов. Микросервисы — это лишь один из способов физически разнести найденные границы.

В этой лекции я буду использовать слово **модуль** для обозначения самостоятельной единицы функционала. То есть систему мы будем делить на модули. При этом модули могут включать в себя другие модули (иерархическая декомпозиция).

Прежде чем углубляться в принципы, важно понять, зачем вообще нужна декомпозиция. Основная причина декомпозиции больших систем — это управление сложностью. Декомпозируя большую систему, мы получаем несколько преимуществ:

- **независимость изменений**: добавление новой фичи не затрагивает поведение других фич;
- **масштабирование команд**: несколько команд разработки могут параллельно работать над одним большим проектом, не мешая друг другу и без необходимости синхронизации релизов;
- **изоляция рисков**: при высоком уровне декомпозиции можно получить систему, в которой отказ отдельных модулей приводит только к частичной деградации бизнес‑процессов;
- при высоком уровне декомпозиции проще адаптировать нагрузку под каждый модуль и масштабировать только горячие участки системы;
- **управление и понимание**: крупная система с хорошо выделенными отдельными модулями проще в освоении новыми участниками команды.

Важно помнить: декомпозиция — это дополнительные накладные расходы, и далеко не всегда систему стоит декомпозировать. Например, если система небольшая, изменения редкие и роста сложности не ожидается, то монолит часто будет проще и быстрее. Декомпозиция становится особенно полезной, когда прикладная область сложная и постоянно меняется; когда нужно независимо масштабировать команды разработки; либо когда важно изолировать риски и сбои. Но даже и в этих случаях на начальных этапах декомпозиция может быть избыточной.

После того как мы поняли, что декомпозиция действительно нужна, можно обсудить подходы к ней. Обычно декомпозиция базируется на нескольких подходах:

- разделение по **бизнес‑возможностям**, чтобы каждая часть отвечала за свою понятную бизнес‑функцию;
- разделение по **данным**: кто какими данными владеет и ими управляет;
- разделение по **изменяемости**: части, которые изменяются совместно, выносятся в один модуль.

Проверять качество разбиения помогают принципы **высокой связности** и **слабого зацепления**. Высокая связность позволит локализовать общие изменения в одном модуле, а слабое зацепление поможет правильно отделить один модуль от другого.

Рассмотрим подходы более подробно.

### Деление по бизнес‑возможностям

Деление по бизнес‑возможностям устроено так, что каждый модуль отвечает за свой ограниченный поддомен. Например, система может быть разделена на модули заказов, оплаты, доставки. Каждый модуль разрабатывается и выпускается независимо. Пользовательские сценарии могут проходить через несколько модулей.

### Деление по владению данными

В этом случае каждый модуль управляет и хранит только свою часть данных. Например, модуль заказов владеет статусами заказов. И никто, кроме модуля заказов, не может напрямую работать с этими данными.

Если же несколько модулей напрямую работают с одними и теми же данными (например, с одной и той же таблицей в БД), то мы получаем проблему высокого зацепления между модулями — и дальше мы рассмотрим этот случай более подробно.

### Деление по изменениям

Если при разработке нам нужно затрагивать несколько частей нашей системы, то удобно держать эти созависимые части в одном модуле. В противном случае у нас появляются созависимые релизные циклы, что усложняет сопровождение системы.

### Деление по профилю нагрузки

Например, функционал поиска имеет ярко выраженную нагрузку на чтение и небольшую нагрузку на запись. В этом случае может быть полезным вынести поиск в отдельный модуль со своим хранилищем, заточенным под быстрое чтение.

### Деление по риску и критичности

Например, функционал обработки платежей или функционал обработки персональных данных может иметь более высокие требования с точки зрения информационной безопасности и контроля доступа. В этом случае также может быть полезным вынести такой функционал в отдельные модули.

### Деление по каналам

Если система имеет несколько каналов взаимодействия (например, мобильное приложение и веб‑приложение), то эти каналы могут развиваться независимо — со своими требованиями и релизными циклами.

### Деление по слоям

Один из самых простых и очевидных способов структурировать систему — разделить её на слои. Например, трёхслойная архитектура предлагает выделять слой представления, слой бизнес‑логики и слой данных. Каждый слой решает свою задачу, а слои взаимодействуют друг с другом через публичные контракты, не погружаясь в детали реализации.

Важно: слои — это прежде всего способ организовать код. Слои почти никогда не становятся границами модулей (в смысле владения данными/ответственностью/релизами). Далее будет показан пример антипаттерна «слой как сервис».

### Принцип единственной ответственности на уровне архитектуры

На предыдущих лекциях мы уже говорили, что SRP применяется на уровне архитектуры. У каждого модуля должна быть только одна причина для изменений. Если у модуля нет ярко выраженной зоны ответственности или помимо неё есть ещё какие‑то дополнительные зоны ответственности, то такой модуль нарушает SRP.

### Как понять, что деление верное

- Добавление новых фичей затрагивает один/два компонента, а не всю систему целиком.
- У данных только один Владелец (также называемый источником истины).
- Контракты и границы между компонентами стабильны: новый функционал не приводит к потере обратной совместимости контрактов, и границы не «переезжают».

### Антипаттерны декомпозиции

**Антипаттерн: God Object**

Модуль сочетает в себе большое количество слабо связанного функционала. При активном добавлении нового функционала в такой модуль он быстро становится очень хрупким, что повышает риск внести ломающие изменения. Также такой модуль требует особого подхода к релизному циклу.

**Антипаттерн: слой как сервис**

Если в трёхслойной архитектуре выделить каждый слой в отдельный сервис, то мы получим три сервиса: UI‑сервис, сервис бизнес‑логики, дата‑сервис. Такое деление приведёт к тому, что каждый запрос будет проходить через цепочку отдельных сервисов, что повысит общее время ответа и увеличит количество сбоев из‑за ненадёжности сети. Но не принесет никаких плюсов от такого разделения.

**Антипаттерн: общая библиотека**

При сильной декомпозиции можно получить ситуацию, когда разные модули используют одни и те же модели, DTO, утилиты, валидаторы бизнес‑логики. В целях снижения дублирования логики может появиться идея вынести повторяющиеся части в общую библиотеку. И несмотря на очевидные плюсы, это решение может привести к высокому зацеплению модулей. Любые изменения в общей библиотеке потенциально могут сломать любой из модулей.

В общую библиотеку можно выносить только стабильные модели контрактов. Всё остальное должно быть сокрыто в деталях реализации каждого модуля. Только в этом случае модули смогут разрабатываться независимо друг от друга.

**Антипаттерн: общая база данных**

Этот антипаттерн схож с антипаттерном «общая библиотека». Проблемы здесь те же: скрытые зависимости, потенциальная возможность сломать чужую схему данных, созависимые релизные циклы, отсутствие единственного источника истины.

---

## Раздел 2. Связанность, зацепление, метрики

При декомпозиции мы стараемся достичь **высокой связности внутри модуля** и **слабого зацепления между модулями**. Связность (внутри модуля) бывает разных типов.

### Функциональная связность 

Тип связности, при котором все задачи, выполняемые программным модулем, вносят вклад в выполнение одной и той же функции. На уровне архитектуры это означает: модуль реализует одну бизнес-возможность/ответственность и имеет одну "причину для изменения" (SRP), поэтому изменения  этой функции локализуются внутри модуля и редко требуют правок в соседних модулях.

### Коммуникационная связность

Тип связности, при котором задачи, выполняемые программным модулем, используют одни и те же входные данные или участвуют в формировании одних и тех же выходных данных. На уровне архитектуры это часто означает, что модуль "собран вокруг данных": он является владельцем определённого набора данных/агрегата и реализует операции его жизненного цикла (чтение, изменение, валидации, проекции)

### Последовательностная связность 

Тип связности, при котором выходные данные одной задачи, выполняемой программным модулем, служат входными данными для другой задачи, выполняемой этим же модулем. На уровне архитектуры это обычно означает, что модуль реализует цельный "workflow/пайплайн" одной бизнес-операции: шаги естественно следуют друг за другом (результат шага A нужен шагу B), и их имеет смысл держать рядом, пока они остаются внутри одной ответственности и одного владельца данных. Если же цепочка шагов проходит через разные домены/владельцев данных, то это уже признак неверной границы: модуль начинает "оркестрировать" чужую логику и повышает зацепление.

### Временна́я связность 

Тип связности, при котором все задачи, выполняемые программным модулем, требуются для некоторой фазы выполнения программы (например, модуль содержит все задачи для инициализации). На уровне архитектуры временная связность часто означает, что модуль "собран вокруг фазы" (startup, инициализация, миграции, прогрев кэшей, планировщик). Это может быть нормально для инфраструктурных задач, но плохо подходит для бизнес-модулей.

### Случайная связность 

Тип связности, при котором задачи, выполняемые программным модулем, не имеют функциональной взаимосвязи друг с другом. На уровне архитектуры случайная связность обычно означает, что модуль собран "по историческим причинам" или "так было удобно", а не по ответственности или данным. Такой модуль почти всегда имеет проблемы границ:  нарушает SRP, быстро разрастается в God Object и начинает тянуть за собой лишние зависимости.

### Зацепление (между модулями) тоже имеет несколько типов

### Зацепление по данным (data coupling, input‑output coupling)

выходные данные одного программного модуля служат входными данными другого модуля. На уровне архитектуры это "здоровый" базовый тип взаимодействия: модули обмениваются только теми данными, которые явно определены в публичном контракте (DTO/события), не раскрывая внутренние модели и детали хранения. Чем меньше и стабильнее этот набор данных, тем слабее зацепление

### Зацепление по управлению (control coupling)

один программный модуль обменивается данными с другим модулем с явной целью повлиять на его последующее выполнение. На уровне архитектуры это означает, что потребитель передаёт поставщику управляющие сигналы, а не только данные. Обычно это проявляется в виде универсальных методов и флагов/режимов/типов исполнения (mode=fast, validateOnly=true, useNewFlow=true). Такой контракт нестабилен: любое добавление нового режима часто требует синхронных изменений в обоих модулях и повышает зацепление.

### Зацепление по общей области (common‑environment coupling, common coupling)

два программных модуля совместно используют общую область данных. На уровне архитектуры это почти всегда означает "shared state": общая таблица в БД, общий кэш, общая файловая папка. Это сильное зацепление. Модуль может изменить общую область и "случайно" сломать другой модуль. Релизы и миграции начинают требовать синхронизации.

### Зацепление по содержимому (content coupling)

некоторые или все программные модули включены в некоторый модуль как составные части. На уровне архитектуры это означает, что один модуль использует внутренние классы/методы другого модуля. Вызывает не-публичные API, работает с внутренним состояним. Это почти всегда сильное зацепление: любое изменение внутренней структуры поставщика начинает ломать потребителей и делает независимую разработку/релизы затруднительными. Антипаттерн "Общая библотека" яркий представитель этого вида зацепления при утечке внутренних моделей/логики.

### Патологическое зацепление (pathological coupling)

один программный модуль зависит от деталей внутренней реализации другого модуля или влияет на них. На уровне реализации выглядит как грязные хаки: использование рефлексии, monkey patching или триггеров в БД. 

### Смена типа зацепления

Возьмём для примера **зацепление по общей области**: оно часто выражается как использование одной таблицы/схемы в БД разными модулями. Такой вид зацепления полезно преобразовывать в более контролируемое взаимодействие — через **зацепление по данным** и публичные **контракты**.

Для этого определяем, какой модуль является **владельцем данных**, а какой — **потребителем**:

- при изменении данных владелец публикует событие об изменении, а потребитель реагирует на такие события;
- либо потребитель синхронно обращается к владельцу за актуальными данными через публичный контракт.

Если выделить одного владельца не получается, то, скорее всего, граница была выбрана неверно: владелец и потребитель должны быть частью одного модуля.

### Метрики зацепления

Из описанных типов зацепления видно, что оно бывает «сильным» и «слабым» (то есть более или менее опасным с точки зрения изменений).

Грубая эвристика: **сильное зацепление** заставляет менять потребителя при любом заметном рефакторинге или изменении внутренностей поставщика; **слабое зацепление** опирается на стабильный публичный контракт и не протаскивает детали реализации наружу.

Роберт Мартин вводит метрику ***Instability*** - мера стабильности модуля от 0 до 1. Выражается формулой I = Ce / (Ca + Ce), где:

1. **Fan-out (efferent coupling, Ce)**: количество модулей, от которых зависит твой модуль (исходящие стрелки на диаграммах).
2. **Fan-in (afferent coupling, Ca)**: сколько модулей *зависят от твоего* (входящие стрелки на диаграммах).

Здесь видно, что метрика не учитывает общее число зависимостей и качество зацепления (его тип). На практике полезно рассматривать зацепление в двух измерениях: силу связи, т.е. тип зависимости: data/control/common/content и размах: сколько модулей вовлечено (fan-in/fan-out).

---

## Раздел 3. Интерфейсы и контракты между компонентами

После того как мы определили границы модулей, нужно определить правила взаимодействия модулей — описать контракты.

Самое близкое понятие к понятию контракта — это интерфейс в ООП. Но в широком смысле контракт — это не только методы и DTO. Контракт также включает в себя следующие свойства:

- **семантика операций** — что означают, какие инварианты поддерживают;
- **форматы данных и правила эволюции** — поддержка обратной совместимости, правила версионирования;
- **ошибки и поведение при сбоях** — таймауты, ретраи, идемпотентность, дедупликация;
- **нефункциональные требования** (non‑functional requirements) — SLA/SLO для latency, availability.

Взаимодействие между модулями можно разделить на два больших вида: синхронное и асинхронное.

- **Синхронное (REST/gRPC)**: удобно для запрос‑ответ и интерактивных сценариев, а также когда результат нужен сразу, как он будет готов. Из минусов — чувствительность к задержкам и недоступности.

- **Асинхронное (events/pub‑sub)**: развязывает во времени и по месту, более устойчивое к временным неполадкам или скачкам нагрузки; удобно для fan‑in и fan‑out сценариев.

  Минусы — более сложная отладка, eventual consistency, саги/оркестрации для распределённых транзакций.

Чтобы сохранять обратную совместимость, полезно придерживаться правила: **контракты безопаснее расширять, чем «ломать»**. На практике это означает:

- не удалять методы/эндпоинты, у которых есть потребители;
- не добавлять новые **обязательные** параметры в запрос (можно добавлять только опциональные, либо вводить новую версию операции);
- не удалять параметры из ответа (можно только добавлять новые поля/значения так, чтобы старые потребители продолжали работать).

На практике для корректной эволюции контрактов использую Реестры Схем Данных, которые валидируют изменения и предотвращают риск случайной поломки обратной совместимости.

Хорошо спроектированный контракт должен покрывать бизнес‑сценарии, учитывать потенциальные проблемы (как, например, повторные дубликаты) и даже в случае ошибок должен вести себя предсказуемо.

Контракты должны быть стабильнее и устойчивее, чем их реализации. Если контракт меняется часто, то это может быть признаком плохого выбора границ модуля.

Контракты могут меняться и эволюционировать, и не всегда потребители могут влиять на этот процесс. Чтобы снизить риск неожиданных изменений, можно опираться на **DIP** (зависеть от абстракций: порты/интерфейсы) и использовать **адаптеры** на границе модуля, чтобы локализовать изменения поставщика внутри адаптера, а не «протаскивать» их по коду потребителя.

